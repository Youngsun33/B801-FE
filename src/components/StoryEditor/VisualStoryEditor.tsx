import React, { useState, useEffect, useRef } from 'react';
import './VisualStoryEditor.css';

interface StoryNode {
  id: number;
  title: string;
  text: string;
  choices: any[];
  rewards: any;
  route_name: string;
  node_type: string;
  image_url?: string;
  image_alt?: string;
  x: number;
  y: number;
}

interface Connection {
  from: number;
  to: number;
  label: string;
}

interface VisualStoryEditorProps {
  nodes: StoryNode[];
  onNodeUpdate: (nodeId: number, data: any) => void;
  onNodeDelete: (nodeId: number) => void;
  onNodesChange: (nodes: StoryNode[]) => void;
  saving?: boolean;
}

const VisualStoryEditor: React.FC<VisualStoryEditorProps> = ({
  nodes,
  onNodeUpdate,
  onNodeDelete,
  onNodesChange,
  saving = false
}) => {
  const [selectedNode, setSelectedNode] = useState<StoryNode | null>(null);
  const [draggedNode, setDraggedNode] = useState<number | null>(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [viewOffset, setViewOffset] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [isFullscreen, setIsFullscreen] = useState(false);
  const canvasRef = useRef<HTMLDivElement>(null);
  const editorRef = useRef<HTMLDivElement>(null);
  const [canvasSize, setCanvasSize] = useState({ width: 6000, height: 4000 });

  // Ï¥àÍ∏∞ Î∑∞ ÏÑ§Ï†ï (Î™®Îì† ÎÖ∏ÎìúÍ∞Ä Î≥¥Ïù¥ÎèÑÎ°ù)
  useEffect(() => {
    if (nodes.length > 0 && viewOffset.x === 0 && viewOffset.y === 0) {
      // Î™®Îì† ÎÖ∏ÎìúÏùò Í≤ΩÍ≥Ñ Í≥ÑÏÇ∞
      const bounds = calculateSVGBounds();
      const centerX = (bounds.minX + bounds.maxX) / 2;
      const centerY = (bounds.minY + bounds.maxY) / 2;
      
      // ÌôîÎ©¥ Ï§ëÏïôÏóê Î™®Îì† ÎÖ∏ÎìúÍ∞Ä Î≥¥Ïù¥ÎèÑÎ°ù Ïò§ÌîÑÏÖã ÏÑ§Ï†ï
      setViewOffset({ 
        x: -centerX + window.innerWidth / 2, 
        y: -centerY + window.innerHeight / 2 
      });
    }
  }, [nodes]);

  // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Ï°∞Ï†ï
  useEffect(() => {
    const updateCanvasSize = () => {
      if (canvasRef.current) {
        const rect = canvasRef.current.getBoundingClientRect();
        setCanvasSize({ width: rect.width, height: rect.height });
      }
    };

    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);
    return () => window.removeEventListener('resize', updateCanvasSize);
  }, []);

  // Ï∫îÎ≤ÑÏä§ Ìå®Îãù ÏãúÏûë
  const handleCanvasMouseDown = (e: React.MouseEvent) => {
    if (e.button === 1 || (e.button === 0 && e.target === canvasRef.current)) {
      setIsPanning(true);
      setPanStart({ x: e.clientX - viewOffset.x, y: e.clientY - viewOffset.y });
    }
  };

  // Ï∫îÎ≤ÑÏä§ Ìå®Îãù Ï§ë
  const handleCanvasMouseMove = (e: React.MouseEvent) => {
    if (isPanning) {
      setViewOffset({
        x: e.clientX - panStart.x,
        y: e.clientY - panStart.y
      });
    } else if (draggedNode) {
      handleNodeDrag(e);
    }
  };

  // Ï∫îÎ≤ÑÏä§ Ìå®Îãù Ï¢ÖÎ£å
  const handleCanvasMouseUp = () => {
    setIsPanning(false);
    if (draggedNode) {
      handleNodeDragEnd();
    }
  };

  // ÎßàÏö∞Ïä§ Ìú† Ïù¥Î≤§Ìä∏ Ï†úÍ±∞

  // ÎÖ∏Îìú ÎìúÎûòÍ∑∏ ÏãúÏûë
  const handleNodeDragStart = (e: React.MouseEvent, nodeId: number) => {
    e.stopPropagation();
    setDraggedNode(nodeId);
    
    const node = nodes.find(n => n.id === nodeId);
    if (node) {
      setDragOffset({
        x: e.clientX - viewOffset.x - node.x,
        y: e.clientY - viewOffset.y - node.y
      });
    }
  };

  // ÎÖ∏Îìú ÎìúÎûòÍ∑∏ Ï§ë
  const handleNodeDrag = (e: React.MouseEvent) => {
    if (draggedNode && canvasRef.current) {
      const newX = e.clientX - viewOffset.x - dragOffset.x;
      const newY = e.clientY - viewOffset.y - dragOffset.y;
      
      const updatedNodes = nodes.map(node =>
        node.id === draggedNode
          ? { ...node, x: newX, y: newY }
          : node
      );
      
      onNodesChange(updatedNodes);
    }
  };

  // ÎÖ∏Îìú ÎìúÎûòÍ∑∏ Ï¢ÖÎ£å
  const handleNodeDragEnd = () => {
    setDraggedNode(null);
    setDragOffset({ x: 0, y: 0 });
  };

  // ÎÖ∏Îìú ÌÅ¥Î¶≠
  const handleNodeClick = (node: StoryNode) => {
    setSelectedNode(node);
  };

  // Ìé∏Ïßë Ìå®ÎÑê Îã´Í∏∞
  const handleCloseEditor = () => {
    setSelectedNode(null);
  };

  // ÎÖ∏Îìú Ï∂îÍ∞Ä
  const handleAddNode = async () => {
    try {
      // Î∞±ÏóîÎìúÏóê ÏÉà ÎÖ∏Îìú ÏÉùÏÑ±
      const response = await fetch('https://b801-be.azurewebsites.net/api/admin/story-nodes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
        },
        body: JSON.stringify({
          title: 'ÏÉà ÎÖ∏Îìú',
          text: 'ÏÉàÎ°úÏö¥ ÎÖ∏ÎìúÏûÖÎãàÎã§. ÎÇ¥Ïö©ÏùÑ Ìé∏ÏßëÌï¥Ï£ºÏÑ∏Ïöî.',
          choices: '[]',
          rewards: null,
          node_type: 'story',
          route_name: null
        }),
      });

      if (response.ok) {
        const result = await response.json();
        console.log(`‚úÖ ÏÉà ÎÖ∏Îìú ${result.node_id} ÏÉùÏÑ± ÏôÑÎ£å!`);
        alert(`ÏÉà ÎÖ∏Îìú ${result.node_id}Í∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!`);
        
        // ÎÖ∏Îìú Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
        onNodesChange([]); // Îπà Î∞∞Ïó¥Î°ú ÏÑ§Ï†ïÌïòÎ©¥ loadStoryNodesÍ∞Ä Ìò∏Ï∂úÎê®
      } else {
        const errorText = await response.text();
        console.error('‚ùå ÎÖ∏Îìú ÏÉùÏÑ± Ïã§Ìå®:', errorText);
        alert('ÎÖ∏Îìú ÏÉùÏÑ± Ïã§Ìå®: ' + errorText);
      }
    } catch (error) {
      console.error('‚ùå ÎÖ∏Îìú ÏÉùÏÑ± Ïò§Î•ò:', error);
      alert('ÎÖ∏Îìú ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  // Ï†ÑÏ≤¥ Ï†ÄÏû• (Î™®Îì† ÎÖ∏ÎìúÏùò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ DBÏóê Ï†ÄÏû•)
  const handleSaveAll = async () => {
    try {
      console.log('üíæ Ï†ÑÏ≤¥ Ï†ÄÏû• ÏãúÏûë...');
      
      // ÌòÑÏû¨ Ìé∏Ïßë Ï§ëÏù∏ ÎÖ∏ÎìúÍ∞Ä ÏûàÎã§Î©¥ Î®ºÏ†Ä Ï†ÄÏû•
      if (selectedNode) {
        console.log(`ÌòÑÏû¨ Ìé∏Ïßë Ï§ëÏù∏ ÎÖ∏Îìú ${selectedNode.id} Ï†ÄÏû• Ï§ë...`);
        // Ìé∏Ïßë Ìå®ÎÑêÏùò ÏûêÎèô Ï†ÄÏû• Î°úÏßÅÏù¥ Ïù¥ÎØ∏ ÏûàÏúºÎØÄÎ°ú Î≥ÑÎèÑ Ï≤òÎ¶¨ Î∂àÌïÑÏöî
      }
      
      // Î™®Îì† ÎÖ∏ÎìúÏùò ÏúÑÏπò Ï†ïÎ≥¥Î•º Ï†ÄÏû• (ÌïÑÏöîÌïú Í≤ΩÏö∞)
      console.log('‚úÖ Ï†ÑÏ≤¥ Ï†ÄÏû• ÏôÑÎ£å!');
      alert('Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!');
      
    } catch (error) {
      console.error('‚ùå Ï†ÑÏ≤¥ Ï†ÄÏû• Ïã§Ìå®:', error);
      alert('Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  // Ï†ÑÏ≤¥ÌôîÎ©¥ ÌÜ†Í∏Ä
  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      editorRef.current?.requestFullscreen();
      setIsFullscreen(true);
    } else {
      document.exitFullscreen();
      setIsFullscreen(false);
    }
  };

  // Ï†ÑÏ≤¥ÌôîÎ©¥ ÏÉÅÌÉú Í∞êÏßÄ
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, []);

  // ÎÖ∏Îìú IDÎ°ú ÎÖ∏Îìú Ï∞æÍ∏∞
  const findNodeById = (id: number) => nodes.find(n => n.id === id);

  // targetNodeIdÎ°ú ÎÖ∏Îìú Ï∞æÍ∏∞
  const findNodeByTargetId = (targetNodeId: number): StoryNode | null => {
    return nodes.find(node => node.id === targetNodeId) || null;
  };

  // ÏÑ†ÌÉùÏßÄÏóêÏÑú targetNodeId Ï∂îÏ∂ú
  const extractTargetNodeId = (choice: any): number | null => {
    if (typeof choice === 'string') {
      try {
        // JSON Î¨∏ÏûêÏó¥Ïù∏ Í≤ΩÏö∞ ÌååÏã±
        const parsed = JSON.parse(choice);
        return parsed.targetNodeId || null;
      } catch {
        return null;
      }
    } else if (choice && typeof choice === 'object') {
      // Ïù¥ÎØ∏ ÌååÏã±Îêú Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
      return choice.targetNodeId || null;
    }
    return null;
  };

  // SVG ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (Î™®Îì† ÎÖ∏ÎìúÏôÄ Ïó∞Í≤∞ÏÑ†ÏùÑ Ìè¨Ìï®)
  const calculateSVGBounds = () => {
    if (nodes.length === 0) return { minX: 0, minY: 0, maxX: 1200, maxY: 800 };
    
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    // Î™®Îì† ÎÖ∏ÎìúÏùò Í≤ΩÍ≥Ñ Í≥ÑÏÇ∞
    nodes.forEach(node => {
      minX = Math.min(minX, node.x);
      minY = Math.min(minY, node.y);
      maxX = Math.max(maxX, node.x + 100);
      maxY = Math.max(maxY, node.y + 80);
      
      // Ïó∞Í≤∞ÏÑ†ÎèÑ Í≥†Î†§
      if (node.choices && node.choices.length > 0) {
        node.choices.forEach((choice, index) => {
          const targetNodeId = extractTargetNodeId(choice);
          const targetNode = targetNodeId ? findNodeByTargetId(targetNodeId) : null;
          if (targetNode) {
            const startX = node.x + 100;
            const startY = node.y + 40 + (index * 15);
            const endX = targetNode.x;
            const endY = targetNode.y + 40;
            
            minX = Math.min(minX, startX, endX);
            minY = Math.min(minY, startY, endY);
            maxX = Math.max(maxX, startX, endX);
            maxY = Math.max(maxY, startY, endY);
          }
        });
      }
    });
    
    // Ïó¨Î∞± Ï∂îÍ∞Ä
    const padding = 200;
    return {
      minX: minX - padding,
      minY: minY - padding,
      maxX: maxX + padding,
      maxY: maxY + padding
    };
  };

  // Ïó∞Í≤∞ÏÑ† Í∑∏Î¶¨Í∏∞ (ÎîîÎ≤ÑÍπÖ Í∞ïÌôî)
  const renderConnections = () => {
    const connections: JSX.Element[] = [];
    let connectionCount = 0;
    let totalChoices = 0;
    
    nodes.forEach(node => {
      if (node.choices && node.choices.length > 0) {
        console.log(`üîç ÎÖ∏Îìú ${node.id} (${node.title})Ïùò choices:`, node.choices);
        
        node.choices.forEach((choice, index) => {
          totalChoices++;
          console.log(`  - ÏÑ†ÌÉùÏßÄ ${index}:`, choice);
          
          // targetNodeId Ï∂îÏ∂ú
          const targetNodeId = extractTargetNodeId(choice);
          console.log(`  - Ï∂îÏ∂úÎêú targetNodeId:`, targetNodeId);
          
          const targetNode = targetNodeId ? findNodeByTargetId(targetNodeId) : null;
          console.log(`  - Ï∞æÏùÄ ÌÉÄÍ≤ü ÎÖ∏Îìú:`, targetNode ? `${targetNode.id} (${targetNode.title})` : 'ÏóÜÏùå');
          
          if (targetNode) {
            connectionCount++;
            
            // ÏãúÏûëÏ†ê: ÎÖ∏Îìú Ïò§Î•∏Ï™Ω Ï§ëÏïô
            const startX = node.x + 100;
            const startY = node.y + 40 + (index * 15);
            
            // ÎÅùÏ†ê: ÌÉÄÍ≤ü ÎÖ∏Îìú ÏôºÏ™Ω Ï§ëÏïô
            const endX = targetNode.x;
            const endY = targetNode.y + 40;
            
            // Í∞ÑÎã®Ìïú ÏßÅÏÑ† Ïó∞Í≤∞
            const midX = (startX + endX) / 2;
            const pathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
            
            console.log(`  ‚úÖ Ïó∞Í≤∞ÏÑ† ÏÉùÏÑ±: (${startX}, ${startY}) -> (${endX}, ${endY})`);
            
            connections.push(
              <g key={`${node.id}-${index}-${targetNode.id}`}>
                <path
                  d={pathData}
                  stroke="#667eea"
                  strokeWidth="3"
                  fill="none"
                  markerEnd="url(#arrowhead)"
                />
              </g>
            );
          } else {
            console.warn(`  ‚ùå Ïó∞Í≤∞ Ïã§Ìå®: targetNodeId ${targetNodeId}Ïóê Ìï¥ÎãπÌïòÎäî ÎÖ∏ÎìúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå`);
          }
        });
      }
    });
    
    console.log(`üìä Ïó∞Í≤∞ÏÑ† Î†åÎçîÎßÅ Í≤∞Í≥º:`);
    console.log(`  - Ï¥ù ÎÖ∏Îìú: ${nodes.length}Í∞ú`);
    console.log(`  - Ï¥ù ÏÑ†ÌÉùÏßÄ: ${totalChoices}Í∞ú`);
    console.log(`  - ÏÑ±Í≥µÌïú Ïó∞Í≤∞: ${connectionCount}Í∞ú`);
    console.log(`  - Ïó∞Í≤∞ Ïã§Ìå®: ${totalChoices - connectionCount}Í∞ú`);
    
    return connections;
  };

  return (
    <div ref={editorRef} className={`visual-story-editor ${isFullscreen ? 'fullscreen' : ''}`}>
      {/* Ìà¥Î∞î */}
      <div className="editor-toolbar">
        <button className="tool-btn" onClick={handleAddNode}>‚ûï ÎÖ∏Îìú Ï∂îÍ∞Ä</button>
        <button className="tool-btn" onClick={() => {
          if (nodes.length > 0) {
            const bounds = calculateSVGBounds();
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            setViewOffset({ 
              x: -centerX + window.innerWidth / 2, 
              y: -centerY + window.innerHeight / 2 
            });
          }
        }}>
          üè† Ï§ëÏïôÏúºÎ°ú
        </button>
        <button className="tool-btn" onClick={toggleFullscreen}>
          {isFullscreen ? 'üóó Ï†ÑÏ≤¥ÌôîÎ©¥ Ï¢ÖÎ£å' : 'üóñ Ï†ÑÏ≤¥ÌôîÎ©¥'}
        </button>
        <button className="tool-btn" onClick={() => {
          console.log('üîç ÌòÑÏû¨ ÎÖ∏ÎìúÎì§:', nodes.length);
          console.log('üîç Î∑∞ Ïò§ÌîÑÏÖã:', viewOffset);
          alert(`ÎÖ∏Îìú: ${nodes.length}Í∞ú, Ïó∞Í≤∞ÏÑ† Î†åÎçîÎßÅ Ï§ë...`);
        }}>
          üîç ÏÉÅÌÉú ÌôïÏù∏
        </button>
        <button className="tool-btn save-all-btn" onClick={handleSaveAll}>
          üíæ Ï†ÄÏû•
        </button>
        <div style={{ marginLeft: 'auto', color: '#666', fontSize: '0.85rem', display: 'flex', alignItems: 'center' }}>
          Îπà Í≥µÍ∞Ñ ÎìúÎûòÍ∑∏: Ï∫îÎ≤ÑÏä§ Ïù¥Îèô | ÎÖ∏Îìú ÎìúÎûòÍ∑∏: ÏúÑÏπò Î≥ÄÍ≤Ω
        </div>
      </div>

      {/* Î©îÏù∏ Ìé∏Ïßë ÏòÅÏó≠ */}
      <div className="editor-main">
        {/* Ï∫îÎ≤ÑÏä§ */}
        <div 
          ref={canvasRef}
          className={`editor-canvas ${isPanning ? 'panning' : ''}`}
          onMouseDown={handleCanvasMouseDown}
          onMouseMove={handleCanvasMouseMove}
          onMouseUp={handleCanvasMouseUp}
          onMouseLeave={handleCanvasMouseUp}
          style={{ cursor: isPanning ? 'grabbing' : draggedNode ? 'move' : 'grab' }}
        >
          {/* SVG Ïó∞Í≤∞ÏÑ† Î†àÏù¥Ïñ¥ */}
          <svg 
            className="connections-layer" 
            width={canvasSize.width * 2} 
            height={canvasSize.height * 2}
            style={{
              transform: `translate(${viewOffset.x}px, ${viewOffset.y}px)`,
              transformOrigin: '0 0',
              pointerEvents: 'none',
              zIndex: 5,
              position: 'absolute',
              top: 0,
              left: 0,
              overflow: 'visible'
            }}
          >
            <defs>
              <marker
                id="arrowhead"
                markerWidth="10"
                markerHeight="7"
                refX="9"
                refY="3.5"
                orient="auto"
              >
                <polygon
                  points="0 0, 10 3.5, 0 7"
                  fill="#667eea"
                />
              </marker>
            </defs>
            {renderConnections()}
          </svg>

          {/* ÎÖ∏ÎìúÎì§ */}
          {nodes.map(node => (
            <div
              key={node.id}
              className={`story-node ${selectedNode?.id === node.id ? 'selected' : ''} ${node.node_type} ${draggedNode === node.id ? 'dragging' : ''} ${node.id === nodes[0]?.id ? 'start' : ''}`}
              style={{ 
                left: node.x, 
                top: node.y,
                transform: `translate(${viewOffset.x}px, ${viewOffset.y}px)`,
                transformOrigin: '0 0',
                zIndex: draggedNode === node.id ? 1000 : 10
              }}
              onClick={(e) => {
                e.stopPropagation();
                handleNodeClick(node);
              }}
              onMouseDown={(e) => handleNodeDragStart(e, node.id)}
            >
              <div className="node-header">
                <div className="node-title">{node.title}</div>
              </div>
              <div className="node-content">
                {node.text.length > 60 ? `${node.text.substring(0, 60)}...` : node.text}
              </div>
              {node.choices && node.choices.length > 0 && (
                <div className="node-choices">
                  <div className="choices-count">‚Üí {node.choices.length}Í∞ú ÏÑ†ÌÉùÏßÄ</div>
                  <div className="choices-preview">
                    {node.choices.slice(0, 2).map((choice, idx) => {
                      let label = '';
                      if (typeof choice === 'string') {
                        label = choice;
                      } else if (choice && choice.label) {
                        label = choice.label;
                      }
                      return (
                        <div key={idx} className="choice-item">
                          ‚Ä¢ {label.length > 20 ? label.substring(0, 20) + '...' : label}
                        </div>
                      );
                    })}
                    {node.choices.length > 2 && (
                      <div className="choice-item">... +{node.choices.length - 2}Í∞ú Îçî</div>
                    )}
                  </div>
                </div>
              )}
              {node.route_name && (
                <div className="node-route">{node.route_name}</div>
              )}
            </div>
          ))}
        </div>

        {/* Ìé∏Ïßë Ìå®ÎÑê */}
        {selectedNode && (
          <div className="editor-panel">
            <div className="panel-header">
              <h4>ÎÖ∏Îìú Ìé∏Ïßë - {selectedNode.title}</h4>
              <button className="close-btn" onClick={handleCloseEditor}>‚úï</button>
            </div>
            <NodeEditor
              node={selectedNode}
              saving={saving}
              onSave={(data) => {
                onNodeUpdate(selectedNode.id, data);
                setSelectedNode(null);
              }}
              onDelete={() => {
                onNodeDelete(selectedNode.id);
                setSelectedNode(null);
              }}
            />
          </div>
        )}
      </div>
    </div>
  );
};

// ÎÖ∏Îìú Ìé∏Ïßë Ïª¥Ìè¨ÎÑåÌä∏
interface NodeEditorProps {
  node: StoryNode;
  saving?: boolean;
  onSave: (data: any) => void;
  onDelete: () => void;
}

const NodeEditor: React.FC<NodeEditorProps> = ({ node, saving = false, onSave, onDelete }) => {
  // ÏÑ†ÌÉùÏßÄÎ•º Í∞úÎ≥Ñ Î∞∞Ïó¥Î°ú Í¥ÄÎ¶¨ (targetNodeId Ìè¨Ìï®)
  const [choices, setChoices] = useState<any[]>(() => {
    return node.choices.map(choice => {
      if (typeof choice === 'string') {
        try {
          const parsed = JSON.parse(choice);
          return parsed;
        } catch {
          return { label: choice, targetNodeId: null };
        }
      } else if (choice && choice.label) {
        return choice;
      }
      return { label: String(choice), targetNodeId: null };
    });
  });

  const [formData, setFormData] = useState({
    title: node.title,
    text: node.text,
    rewards: node.rewards ? Object.entries(node.rewards).map(([k, v]) => `${k}:${v}`).join(', ') : '',
    route_name: node.route_name || '',
    image_url: node.image_url || '',
    image_alt: node.image_alt || '',
  });

  // ÏûêÎèô Ï†ÄÏû• Í∏∞Îä•
  const autoSave = () => {
    // ÏÑ†ÌÉùÏßÄÎ•º JSON Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
    const choicesString = JSON.stringify(choices.filter(choice => choice.label && choice.label.trim()));
    onSave({ ...formData, choices: choicesString });
  };

  // ÏûÖÎ†•Í∞íÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ ÏûêÎèô Ï†ÄÏû• (ÎîîÎ∞îÏö¥Ïã±)
  React.useEffect(() => {
    const timeoutId = setTimeout(() => {
      // Ïã§Ï†úÎ°ú Î≥ÄÍ≤ΩÎêú ÎÇ¥Ïö©Ïù¥ ÏûàÏùÑ ÎïåÎßå Ï†ÄÏû•
      const hasChanges = formData.title !== node.title || 
                        formData.text !== node.text ||
                        formData.route_name !== (node.route_name || '');
      
      if (hasChanges || choices.length > 0) {
        autoSave();
      }
    }, 2000); // 2Ï¥à ÌõÑ ÏûêÎèô Ï†ÄÏû• (ÌÉÄÏù¥Ìïë ÏôÑÎ£å ÌõÑ)

    return () => clearTimeout(timeoutId);
  }, [formData, choices]);

  const handleSave = () => {
    autoSave();
  };

  // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ï≤òÎ¶¨
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      const formData = new FormData();
      formData.append('image', file);

      const response = await fetch('https://b801-be.azurewebsites.net/api/admin/upload/image', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
        },
        body: formData,
      });

      if (response.ok) {
        const result = await response.json();
        handleInputChange('image_url', result.fileUrl);
        console.log('‚úÖ Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏÑ±Í≥µ:', result.fileUrl);
      } else {
        const error = await response.text();
        console.error('‚ùå Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®:', error);
        alert('Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìúÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïò§Î•ò:', error);
      alert('Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  const handleInputChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  const handleChoiceChange = (index: number, field: string, value: string) => {
    const newChoices = [...choices];
    newChoices[index] = { ...newChoices[index], [field]: value };
    setChoices(newChoices);
  };

  const addChoice = () => {
    setChoices([...choices, { label: '', targetNodeId: null }]);
  };

  const removeChoice = (index: number) => {
    setChoices(choices.filter((_, i) => i !== index));
  };

  return (
    <div className="node-editor-form">
      <div className="form-group">
        <label>Ï†úÎ™©</label>
        <input
          type="text"
          value={formData.title}
          onChange={(e) => handleInputChange('title', e.target.value)}
          placeholder="ÎÖ∏Îìú Ï†úÎ™©"
        />
      </div>

      <div className="form-group">
        <label>ÎÇ¥Ïö©</label>
        <textarea
          value={formData.text}
          onChange={(e) => handleInputChange('text', e.target.value)}
          placeholder="Ïä§ÌÜ†Î¶¨ ÎÇ¥Ïö©"
          rows={4}
        />
      </div>

      <div className="form-group">
        <label>ÏÑ†ÌÉùÏßÄ</label>
        <div className="choices-container">
          {choices.map((choice, index) => (
            <div key={index} className="choice-input-group">
              <input
                type="text"
                value={choice.label || ''}
                onChange={(e) => handleChoiceChange(index, 'label', e.target.value)}
                placeholder={`ÏÑ†ÌÉùÏßÄ ${index + 1} ÌÖçÏä§Ìä∏`}
                className="choice-input"
              />
              <input
                type="number"
                value={choice.targetNodeId || ''}
                onChange={(e) => handleChoiceChange(index, 'targetNodeId', parseInt(e.target.value) || null)}
                placeholder="ÌÉÄÍ≤ü ÎÖ∏Îìú ID"
                className="choice-target-input"
              />
              <button
                type="button"
                onClick={() => removeChoice(index)}
                className="remove-choice-btn"
                title="ÏÑ†ÌÉùÏßÄ ÏÇ≠Ï†ú"
              >
                ‚úï
              </button>
            </div>
          ))}
          <button
            type="button"
            onClick={addChoice}
            className="add-choice-btn"
          >
            ‚ûï ÏÑ†ÌÉùÏßÄ Ï∂îÍ∞Ä
          </button>
        </div>
      </div>

      <div className="form-group">
        <label>Î≥¥ÏÉÅ (ÌÇ§:Í∞í,ÌÇ§:Í∞í ÌòïÌÉú)</label>
        <input
          type="text"
          value={formData.rewards}
          onChange={(e) => handleInputChange('rewards', e.target.value)}
          placeholder="Í≥®Îìú:100, ÏóêÎÑàÏßÄ:50"
        />
      </div>

      <div className="form-group">
        <label>Î£®Ìä∏ Ïù¥Î¶Ñ</label>
        <input
          type="text"
          value={formData.route_name}
          onChange={(e) => handleInputChange('route_name', e.target.value)}
          placeholder="Î£®Ìä∏ 1, Î£®Ìä∏ 2 Îì±"
        />
      </div>

      <div className="form-group">
        <label>Ïù¥ÎØ∏ÏßÄ ÌååÏùº</label>
        <input
          type="file"
          accept="image/*"
          onChange={handleImageUpload}
          className="file-input"
        />
        {formData.image_url && (
          <div className="current-image">
            <span>ÌòÑÏû¨ Ïù¥ÎØ∏ÏßÄ: {formData.image_url}</span>
            <button 
              type="button" 
              onClick={() => handleInputChange('image_url', '')}
              className="remove-image-btn"
            >
              Ï†úÍ±∞
            </button>
          </div>
        )}
      </div>

      <div className="form-group">
        <label>Ïù¥ÎØ∏ÏßÄ ÏÑ§Î™Ö</label>
        <input
          type="text"
          value={formData.image_alt}
          onChange={(e) => handleInputChange('image_alt', e.target.value)}
          placeholder="Ïù¥ÎØ∏ÏßÄÏóê ÎåÄÌïú ÏÑ§Î™Ö"
        />
      </div>

      {formData.image_url && (
        <div className="form-group">
          <label>Ïù¥ÎØ∏ÏßÄ ÎØ∏Î¶¨Î≥¥Í∏∞</label>
          <div className="image-preview">
            <img 
              src={formData.image_url} 
              alt={formData.image_alt || 'ÎÖ∏Îìú Ïù¥ÎØ∏ÏßÄ'}
              onError={(e) => {
                e.currentTarget.style.display = 'none';
                e.currentTarget.nextElementSibling!.style.display = 'block';
              }}
            />
            <div className="image-error" style={{ display: 'none' }}>
              Ïù¥ÎØ∏ÏßÄÎ•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.
            </div>
          </div>
        </div>
      )}

      <div className="form-actions">
        <div className="auto-save-status">
          {saving ? 'üíæ Ï†ÄÏû• Ï§ë...' : '‚úÖ ÏûêÎèô Ï†ÄÏû•Îê®'}
        </div>
        <button 
          className="save-btn" 
          onClick={handleSave}
          disabled={saving}
        >
          {saving ? 'üíæ Ï†ÄÏû• Ï§ë...' : 'üíæ Ï†ÄÏû•'}
        </button>
        <button className="delete-btn" onClick={onDelete}>
          üóëÔ∏è ÏÇ≠Ï†ú
        </button>
      </div>
    </div>
  );
};

export default VisualStoryEditor;
